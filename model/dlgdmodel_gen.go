// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.8.3

package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	dlgdFieldNames          = builder.RawFieldNames(&Dlgd{})
	dlgdRows                = strings.Join(dlgdFieldNames, ",")
	dlgdRowsExpectAutoSet   = strings.Join(stringx.Remove(dlgdFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	dlgdRowsWithPlaceHolder = strings.Join(stringx.Remove(dlgdFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheEdsCronDlgdIdPrefix                                = "cache:edsCron:dlgd:id:"
	cacheEdsCronDlgdAreaStartTimeCategoryVoltageStagePrefix = "cache:edsCron:dlgd:area:startTime:category:voltage:stage:"
)

type (
	dlgdModel interface {
		Insert(ctx context.Context, data *Dlgd) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*Dlgd, error)
		FindOneByAreaStartTimeCategoryVoltageStage(ctx context.Context, area string, startTime time.Time, category string, voltage string, stage string) (*Dlgd, error)
		Update(ctx context.Context, data *Dlgd) error
		Delete(ctx context.Context, id int64) error
	}

	defaultDlgdModel struct {
		sqlc.CachedConn
		table string
	}

	Dlgd struct {
		Id         int64     `db:"id"`
		Area       string    `db:"area"`        // 区域
		StartTime  time.Time `db:"start_time"`  // 执行起始时间（含）
		EndTime    time.Time `db:"end_time"`    // 执行截止时间（不含）
		Category   string    `db:"category"`    // 用电分类，如单一制、两部制
		Voltage    string    `db:"voltage"`     // 电压等级，如1-10（20）千伏
		Stage      string    `db:"stage"`       // 阶梯阈值，如深圳
		Fund       float64   `db:"fund"`        // 政府性基金及附加，力调电费需排除
		Sharp      float64   `db:"sharp"`       // 尖峰电价
		SharpDate  string    `db:"sharp_date"`  // 尖峰日期
		SharpHour  string    `db:"sharp_hour"`  // 尖峰时段，如1100-1130,2200-0700
		Peak       float64   `db:"peak"`        // 高峰电价
		PeakDate   string    `db:"peak_date"`   // 高峰日期
		PeakHour   string    `db:"peak_hour"`   // 高峰时段
		Flat       float64   `db:"flat"`        // 平段电价
		FlatDate   string    `db:"flat_date"`   // 平段日期
		FlatHour   string    `db:"flat_hour"`   // 平段时段
		Valley     float64   `db:"valley"`      // 低谷电价
		ValleyDate string    `db:"valley_date"` // 低谷日期
		ValleyHour string    `db:"valley_hour"` // 低谷时段
		Deep       float64   `db:"deep"`        // 深谷电价
		DeepDate   string    `db:"deep_date"`   // 深谷日期,weekend,holiday:元旦:春节,weather>35
		DeepHour   string    `db:"deep_hour"`   // 深谷时段
		Demand     float64   `db:"demand"`      // 需量电价
		Capacity   float64   `db:"capacity"`    // 容量电价
		CreateTime time.Time `db:"create_time"`
		UpdateTime time.Time `db:"update_time"`
	}
)

func newDlgdModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultDlgdModel {
	return &defaultDlgdModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`dlgd`",
	}
}

func (m *defaultDlgdModel) Delete(ctx context.Context, id int64) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		return err
	}

	edsCronDlgdAreaStartTimeCategoryVoltageStageKey := fmt.Sprintf("%s%v:%v:%v:%v:%v", cacheEdsCronDlgdAreaStartTimeCategoryVoltageStagePrefix, data.Area, data.StartTime, data.Category, data.Voltage, data.Stage)
	edsCronDlgdIdKey := fmt.Sprintf("%s%v", cacheEdsCronDlgdIdPrefix, id)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, edsCronDlgdAreaStartTimeCategoryVoltageStageKey, edsCronDlgdIdKey)
	return err
}

func (m *defaultDlgdModel) FindOne(ctx context.Context, id int64) (*Dlgd, error) {
	edsCronDlgdIdKey := fmt.Sprintf("%s%v", cacheEdsCronDlgdIdPrefix, id)
	var resp Dlgd
	err := m.QueryRowCtx(ctx, &resp, edsCronDlgdIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", dlgdRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultDlgdModel) FindOneByAreaStartTimeCategoryVoltageStage(ctx context.Context, area string, startTime time.Time, category string, voltage string, stage string) (*Dlgd, error) {
	edsCronDlgdAreaStartTimeCategoryVoltageStageKey := fmt.Sprintf("%s%v:%v:%v:%v:%v", cacheEdsCronDlgdAreaStartTimeCategoryVoltageStagePrefix, area, startTime, category, voltage, stage)
	var resp Dlgd
	err := m.QueryRowIndexCtx(ctx, &resp, edsCronDlgdAreaStartTimeCategoryVoltageStageKey, m.formatPrimary, func(ctx context.Context, conn sqlx.SqlConn, v any) (i any, e error) {
		query := fmt.Sprintf("select %s from %s where `area` = ? and `start_time` = ? and `category` = ? and `voltage` = ? and `stage` = ? limit 1", dlgdRows, m.table)
		if err := conn.QueryRowCtx(ctx, &resp, query, area, startTime, category, voltage, stage); err != nil {
			return nil, err
		}
		return resp.Id, nil
	}, m.queryPrimary)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultDlgdModel) Insert(ctx context.Context, data *Dlgd) (sql.Result, error) {
	edsCronDlgdAreaStartTimeCategoryVoltageStageKey := fmt.Sprintf("%s%v:%v:%v:%v:%v", cacheEdsCronDlgdAreaStartTimeCategoryVoltageStagePrefix, data.Area, data.StartTime, data.Category, data.Voltage, data.Stage)
	edsCronDlgdIdKey := fmt.Sprintf("%s%v", cacheEdsCronDlgdIdPrefix, data.Id)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, dlgdRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.Area, data.StartTime, data.EndTime, data.Category, data.Voltage, data.Stage, data.Fund, data.Sharp, data.SharpDate, data.SharpHour, data.Peak, data.PeakDate, data.PeakHour, data.Flat, data.FlatDate, data.FlatHour, data.Valley, data.ValleyDate, data.ValleyHour, data.Deep, data.DeepDate, data.DeepHour, data.Demand, data.Capacity)
	}, edsCronDlgdAreaStartTimeCategoryVoltageStageKey, edsCronDlgdIdKey)
	return ret, err
}

func (m *defaultDlgdModel) Update(ctx context.Context, newData *Dlgd) error {
	data, err := m.FindOne(ctx, newData.Id)
	if err != nil {
		return err
	}

	edsCronDlgdAreaStartTimeCategoryVoltageStageKey := fmt.Sprintf("%s%v:%v:%v:%v:%v", cacheEdsCronDlgdAreaStartTimeCategoryVoltageStagePrefix, data.Area, data.StartTime, data.Category, data.Voltage, data.Stage)
	edsCronDlgdIdKey := fmt.Sprintf("%s%v", cacheEdsCronDlgdIdPrefix, data.Id)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, dlgdRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, newData.Area, newData.StartTime, newData.EndTime, newData.Category, newData.Voltage, newData.Stage, newData.Fund, newData.Sharp, newData.SharpDate, newData.SharpHour, newData.Peak, newData.PeakDate, newData.PeakHour, newData.Flat, newData.FlatDate, newData.FlatHour, newData.Valley, newData.ValleyDate, newData.ValleyHour, newData.Deep, newData.DeepDate, newData.DeepHour, newData.Demand, newData.Capacity, newData.Id)
	}, edsCronDlgdAreaStartTimeCategoryVoltageStageKey, edsCronDlgdIdKey)
	return err
}

func (m *defaultDlgdModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheEdsCronDlgdIdPrefix, primary)
}

func (m *defaultDlgdModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", dlgdRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultDlgdModel) tableName() string {
	return m.table
}
