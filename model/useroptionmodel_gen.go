// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.8.3

package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	userOptionFieldNames          = builder.RawFieldNames(&UserOption{})
	userOptionRows                = strings.Join(userOptionFieldNames, ",")
	userOptionRowsExpectAutoSet   = strings.Join(stringx.Remove(userOptionFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	userOptionRowsWithPlaceHolder = strings.Join(stringx.Remove(userOptionFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheEdsCronUserOptionIdPrefix          = "cache:edsCron:userOption:id:"
	cacheEdsCronUserOptionAccountAreaPrefix = "cache:edsCron:userOption:account:area:"
)

type (
	userOptionModel interface {
		Insert(ctx context.Context, data *UserOption) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*UserOption, error)
		FindOneByAccountArea(ctx context.Context, account string, area string) (*UserOption, error)
		Update(ctx context.Context, data *UserOption) error
		Delete(ctx context.Context, id int64) error
	}

	defaultUserOptionModel struct {
		sqlc.CachedConn
		table string
	}

	UserOption struct {
		Id             int64   `db:"id"`
		Account        string  `db:"account"`           // 工程ID
		Area           string  `db:"area"`              // 区域、设备ID、支路名称或ID等
		Category       string  `db:"category"`          // 用电类别，如福建>工商业,两部制>1-10（20）千伏
		PowerFactor    float64 `db:"power_factor"`      // [大陆]功率因素标准，限定0.8/0.85/0.9
		Capacity       float64 `db:"capacity"`          // [大陆]合同容量(kVA)
		Demand         float64 `db:"demand"`            // [大陆]合同需量(kW)
		InstalledCap   float64 `db:"installed_cap"`     // [台湾]装置契约(kW)
		RegularCap     float64 `db:"regular_cap"`       // [台湾]经常契约(kW)
		NonSummerCap   float64 `db:"non_summer_cap"`    // [台湾]非夏月契约(kW)
		SemiPeakCap    float64 `db:"semi_peak_cap"`     // [台湾]半尖峰契约(kW)
		SatSemiPeakCap float64 `db:"sat_semi_peak_cap"` // [台湾]周六半尖峰契约(kW)
		OffPeakCap     float64 `db:"off_peak_cap"`      // [台湾]离峰契约(kW)
	}
)

func newUserOptionModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultUserOptionModel {
	return &defaultUserOptionModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`user_option`",
	}
}

func (m *defaultUserOptionModel) Delete(ctx context.Context, id int64) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		return err
	}

	edsCronUserOptionAccountAreaKey := fmt.Sprintf("%s%v:%v", cacheEdsCronUserOptionAccountAreaPrefix, data.Account, data.Area)
	edsCronUserOptionIdKey := fmt.Sprintf("%s%v", cacheEdsCronUserOptionIdPrefix, id)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, edsCronUserOptionAccountAreaKey, edsCronUserOptionIdKey)
	return err
}

func (m *defaultUserOptionModel) FindOne(ctx context.Context, id int64) (*UserOption, error) {
	edsCronUserOptionIdKey := fmt.Sprintf("%s%v", cacheEdsCronUserOptionIdPrefix, id)
	var resp UserOption
	err := m.QueryRowCtx(ctx, &resp, edsCronUserOptionIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", userOptionRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultUserOptionModel) FindOneByAccountArea(ctx context.Context, account string, area string) (*UserOption, error) {
	edsCronUserOptionAccountAreaKey := fmt.Sprintf("%s%v:%v", cacheEdsCronUserOptionAccountAreaPrefix, account, area)
	var resp UserOption
	err := m.QueryRowIndexCtx(ctx, &resp, edsCronUserOptionAccountAreaKey, m.formatPrimary, func(ctx context.Context, conn sqlx.SqlConn, v any) (i any, e error) {
		query := fmt.Sprintf("select %s from %s where `account` = ? and `area` = ? limit 1", userOptionRows, m.table)
		if err := conn.QueryRowCtx(ctx, &resp, query, account, area); err != nil {
			return nil, err
		}
		return resp.Id, nil
	}, m.queryPrimary)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultUserOptionModel) Insert(ctx context.Context, data *UserOption) (sql.Result, error) {
	edsCronUserOptionAccountAreaKey := fmt.Sprintf("%s%v:%v", cacheEdsCronUserOptionAccountAreaPrefix, data.Account, data.Area)
	edsCronUserOptionIdKey := fmt.Sprintf("%s%v", cacheEdsCronUserOptionIdPrefix, data.Id)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, userOptionRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.Account, data.Area, data.Category, data.PowerFactor, data.Capacity, data.Demand, data.InstalledCap, data.RegularCap, data.NonSummerCap, data.SemiPeakCap, data.SatSemiPeakCap, data.OffPeakCap)
	}, edsCronUserOptionAccountAreaKey, edsCronUserOptionIdKey)
	return ret, err
}

func (m *defaultUserOptionModel) Update(ctx context.Context, newData *UserOption) error {
	data, err := m.FindOne(ctx, newData.Id)
	if err != nil {
		return err
	}

	edsCronUserOptionAccountAreaKey := fmt.Sprintf("%s%v:%v", cacheEdsCronUserOptionAccountAreaPrefix, data.Account, data.Area)
	edsCronUserOptionIdKey := fmt.Sprintf("%s%v", cacheEdsCronUserOptionIdPrefix, data.Id)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, userOptionRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, newData.Account, newData.Area, newData.Category, newData.PowerFactor, newData.Capacity, newData.Demand, newData.InstalledCap, newData.RegularCap, newData.NonSummerCap, newData.SemiPeakCap, newData.SatSemiPeakCap, newData.OffPeakCap, newData.Id)
	}, edsCronUserOptionAccountAreaKey, edsCronUserOptionIdKey)
	return err
}

func (m *defaultUserOptionModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheEdsCronUserOptionIdPrefix, primary)
}

func (m *defaultUserOptionModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", userOptionRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultUserOptionModel) tableName() string {
	return m.table
}
